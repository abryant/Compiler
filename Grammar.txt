The grammar for language X
===================================================================================================

###################
  Top Level Stuff
###################

CompilationUnit = epsilon
                | CompilationUnit PackageDeclaration
                | CompilationUnit ImportDeclaration
                | CompilationUnit TypeDefinition

PackageDeclaration = PackageKeyword QName SemiColon

ImportDeclaration  = ImportKeyword QName Semicolon
                   | ImportKeyword QName Dot Star Semicolon
                   | ImportKeyword StaticKeyword QName Semicolon
                   | ImportKeyword StaticKeyword QName Dot Star Semicolon

TypeDefinition = ClassDefinition
               | InterfaceDefinition
               | EnumDefinition

###############
  Class Stuff
###############


AccessSpecifier = PublicKeyword | PrivateKeyword | PackageKeyword | ProtectedKeyword
                | PackageKeyword ProtectedKeyword | ProtectedKeyword PackageKeyword
                | epsilon

Modifiers = Modifier | Modifiers Modifier
Modifier = StaticKeyword | AbstractKeyword | FinalKeyword | ImmutableKeyword | MutableKeyword
         | SynchronizedKeyword | NativeSpecifier | SinceSpecifier | TransientKeyword | VolatileKeyword
NativeSpecifier = NativeKeyword LParen StringLiteral RParen
SinceSpecifier = SinceKeyword LParen VersionNumber RParen
VersionNumber = IntegerLiteral | VersionNumber Dot IntegerLiteral

MemberHeader = AccessSpecifier Modifiers | AccessSpecifier

ClassDefinition     = MemberHeader ClassKeyword Name ClassExtendsClause ImplementsClause LBrace MemberList RBrace
                    | MemberHeader ClassKeyword Name TypeArguments ClassExtendsClause ImplementsClause LBrace MemberList RBrace
InterfaceDefinition = MemberHeader InterfaceKeyword Name TypeArguments InterfaceExtendsClause LBrace MemberList RBrace

EnumDefinition = MemberHeader EnumKeyword Name ClassExtendsClause ImplementsClause LBrace EnumConstants Semicolon MemberList RBrace
               | MemberHeader EnumKeyword Name ClassExtendsClause ImplementsClause LBrace EnumConstants RBrace

EnumConstants = EnumConstantList Comma | EnumConstantList | epsilon
EnumConstantList = EnumConstantList Comma EnumConstant
                 | EnumConstant
EnumConstant = Name | Name Parameters

ClassExtendsClause     = ExtendsKeyword PointerType | epsilon
ImplementsClause       = ImplementsKeyword InterfaceList | epsilon
InterfaceExtendsClause = ExtendsKeyword InterfaceList | epsilon
InterfaceList          = InterfaceList Comma PointerType | PointerType

MemberList = MemberList Member | epsilon
Member = Constructor | Method | Field | StaticInitializer | TypeDefinition

Constructor = MemberHeader Name Arguments ThrowsClause Block

Method = MemberHeader TypeArguments Type Name Arguments ThrowsClause Semicolon
       | MemberHeader TypeArguments Type Name Arguments ThrowsClause Block
       | MemberHeader               Type Name Arguments ThrowsClause Semicolon
       | MemberHeader               Type Name Arguments ThrowsClause Block

ThrowsClause = ThrowsKeyword ThrowsList | epsilon
ThrowsList = PointerType | ThrowsList Comma PointerType

Field = MemberHeader Type AssigneeList Equals Expression Semicolon
      | MemberHeader Type AssigneeList Semicolon

Property = MemberHeader PropertyKeyword Type Name Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier AssignKeyword OptionalBlock AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier RetrieveKeyword OptionalBlock AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier AssignKeyword OptionalBlock AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier RetrieveKeyword OptionalBlock AccessSpecifier AssignKeyword OptionalBlock Semicolon

OptionalBlock = Block | epsilon

// MemberHeader is used here instead of StaticKeyword to avoid shift-reduce conflicts with "static"
// for example: static {int -> void} foo;
// since this should normally shift with a static initializer and reduce to a MemberHeader for Field
StaticInitializer = MemberHeader Block

Arguments = LParen ArgumentList RParen | LParen RParen
ArgumentList = Argument | ArgumentList Comma Argument
Argument = Modifiers Type Name
         | Modifiers Type At Name Equals ExpressionNoTuple
         | Modifiers Type Ellipsis Name
         | Type Name
         | Type At Name Equals ExpressionNoTuple
         | Type Ellipsis Name
         | Arguments

Parameters = LParen ParameterList RParen
           | LParen RParen
ParameterList = Parameter | ParameterList Comma Parameter
Parameter = At Name Equals ExpressionNoTuple
          | ExpressionNoTuple


#########################
  Blocks and Statements
#########################

Block = LBrace RBrace
      | LBrace Statements RBrace
Statements = Statement | Statements Statement

Statement = Block
          | EmptyStatement
          | ConstructorInvocationStatement
          | LocalDeclarationStatement
          | StatementExpression Semicolon
          | AssignStatement
          | IfStatement
          | WhileStatement
          | DoStatement
          | ForStatement
          | SwitchStatement
          | BreakStatement
          | ContinueStatement
          | FallthroughStatement
          | ReturnStatement
          | SynchronizedStatement
          | ThrowStatement
          | TryStatement
          | IncrementStatement
          | DecrementStatement

EmptyStatement = Semicolon

// should only be used in constructors - check after parsing
ConstructorInvocationStatement = ThisKeyword Parameters Semicolon
                               | SuperKeyword Parameters Semicolon

LocalDeclaration = Type AssigneeList // check that underscore is not declared after parsing
                 | Type AssigneeList Equals Expression
                 | Modifiers Type AssigneeList
                 | Modifiers Type AssigneeList Equals Expression
LocalDeclarationStatement = LocalDeclaration Semicolon

AssignStatement = Assignment Semicolon
Assignment = AssigneeList AssignmentOperator Expression

// right-recursive list, so that the symbol after the list can be
// used to decide between TypeList and AssigneeList
AssigneeList = Assignee | Assignee Comma AssigneeList
Assignee = FieldAccessExpression | ArrayAccessExpression | Underscore

IfStatement = IfKeyword Expression Block ElseIfClauses ElseClause
ElseIfClauses = epsilon | ElseIfClauses ElseIfClause
ElseIfClause = ElseKeyword IfKeyword Expression Block
ElseClause = epsilon | ElseKeyword Block

WhileStatement = WhileKeyword Expression Block

DoStatement = DoKeyword Block WhileKeyword Expression Semicolon

ForStatement = ForKeyword LParen ForHeader RParen Block
             | ForKeyword ForHeader Block
ForHeader = ForInit Semicolon Expression Semicolon ForUpdate
          | ForInit Semicolon            Semicolon ForUpdate
          | Type Name Colon Expression

ForInit = LocalDeclaration | StatementExpression | Assignment | epsilon
ForUpdate = StatementExpression | Assignment | Increment | Decrement | epsilon

SwitchStatement = SwitchKeyword Expression SwitchBlock
                | SwitchKeyword SwitchBlock
SwitchBlock = LBrace SwitchCases RBrace
SwitchCases = epsilon | SwitchCases SwitchCase
SwitchCase = SwitchLabel | SwitchLabel Statements
SwitchLabel = DefaultKeyword Colon
            | CaseKeyword Expression Colon

BreakStatement = BreakKeyword IntegerLiteral Semicolon
               | BreakKeyword Semicolon
ContinueStatement = ContinueKeyword IntegerLiteral Semicolon
                  | ContinueKeyword Semicolon
FallthroughStatement = FallthroughKeyword IntegerLiteral Semicolon
                     | FallthroughKeyword Semicolon

ReturnStatement = Return Expression Semicolon | Return Semicolon

ThrowStatement = ThrowKeyword Expression Semicolon

SynchronizedStatement = SynchronizedKeyword Expression Block
                      | SynchronizedKeyword Block

TryStatement = TryKeyword Block CatchClauses FinallyClause
CatchClauses = epsilon | CatchClauses CatchClause
CatchClause = CatchKeyword CatchDeclaration Block
CatchDeclaration = LParen QName Name RParen
                 | QName Name
FinallyClause = FinallyKeyword Block | epsilon

Increment = FieldAccessExpression Plus Plus   | Plus Plus FieldAccessExpression
Decrement = FieldAccessExpression Minus Minus | Minus Minus FieldAccessExpression
IncrementStatement = Increment Semicolon
DecrementStatement = Decrement Semicolon

###############
  Expressions
###############

StatementExpression = MethodCallExpression | InstanciationExpression

Expression = TupleExpression
TupleExpression = InlineIfExpression | TupleExpession Comma InlineIfExpression

ExpressionNoTuple = InlineIfExpression

InlineIfExpression = BooleanOrExpression | BooleanOrExpression QuestionMark Expression Colon InlineIfExpression

BooleanOrExpression = BooleanXorExpression | BooleanOrExpression DoublePipe BooleanXorExpression
BooleanXorExpression = BooleanAndExpression | BooleanXorExpression DoubleCaret BooleanAndExpression
BooleanAndExpression = EqualityExpression | BooleanAndExpression DoubleAmpersand EqualityExpression

EqualityExpression = RelationalExpression
                   | EqualityExpression DoubleEquals RelationalExpression
                   | EqualityExpression ExclaimationMarkEquals RelationalExpression

RelationalExpression = BitwiseOrExpression
                     | BitwiseOrExpression LAngle BitwiseOrExpression
                     | BitwiseOrExpression RAngle BitwiseOrExpression
                     | BitwiseOrExpression LAngleEquals BitwiseOrExpression
                     | BitwiseOrExpression RAngleEquals BitwiseOrExpression
                     | BitwiseOrExpression InstanceOfKeyword Type

BitwiseOrExpression  = BitwiseXorExpression | BitwiseOrExpression Pipe BitwiseXorExpression 
BitwiseXorExpression = BitwiseAndExpression | BitwiseXorExpression Caret BitwiseAndExpression 
BitwiseAndExpression = ShiftExpression      | BitwiseAndExpression Ampersand ShiftExpression 

ShiftExpression = AdditiveExpression
                | ShiftExpression DoubleLAngle AdditiveExpression
                | ShiftExpression DoubleRAngle AdditiveExpression
                | ShiftExpression DoubleRAngle RAngle AdditiveExpression // check while matching this production that the RAngles are directly next to each other

AdditiveExpression = MultiplicativeExpression
                   | AdditiveExpression Plus MultiplicativeExpression
                   | AdditiveExpression Minus MultiplicativeExpression

MultiplicativeExpression = TupleIndexExpression
                         | MultiplicativeExpression Star TupleIndexExpression
                         | MultiplicativeExpression ForwardSlash TupleIndexExpression
                         | MultiplicativeExpression Percent TupleIndexExpression

TupleIndexExpression = UnaryExpression
                     | TupleIndexExpression ExclaimationMark IntegerLiteral
// TODO: should this be a constant expression instead of an integer literal?

UnaryExpression = Primary | BooleanNotExpression | BitwiseNotExpression | CastExpression | PlusExpression | MinusExpression
BooleanNotExpression = ExclaimationMark UnaryExpression
BitwiseNotExpression = Tilde UnaryExpression
CastExpression = CastKeyword LAngle TypeRAngle UnaryExpression
PlusExpression = Plus UnaryExpression
MinusExpression = Minus UnaryExpression

Primary = PrimaryNotQName | QName

// QNames are excluded here so that FieldAccessExpression can have a production that allows ".name" on the end
// of any Primary that is not already a QName
PrimaryNotQName = PrimaryNoTrailingDimensionsNotQName | ArrayInstanciationExpressionNoInitializer

// Trailing Dimensions from ArrayInstanciationNoInitializer are excluded here so that
// ArrayAccessExpression doesn't have a chance to parse the last part of: new Object[2][0]
// QNames are excluded here so that ArrayAccessExpression can have its own production for QName,
// which resolves a potential shift reduce conflict between an ArrayType and an ArrayAccessExpression
PrimaryNoTrailingDimensionsNotQName = LParen Expression RParen
                                    | IntegerLiteral | FloatingLiteral | CharacterLiteral | StringLiteral | NilLiteral
                                    | FieldAccessExpressionNotQName
                                    | StatementExpression
                                    | ThisAccessExpression
                                    | ArrayAccessExpression
                                    | ClosureCreationExpression
                                    | ArrayInstanciationExpressionWithInitializer

MethodCallExpression = Primary Parameters

FieldAccessExpression = QName | FieldAccessExpressionNotQName
FieldAccessExpressionNotQName = PrimaryNotQName Dot Name
                              | SuperKeyword Dot Name
                              | QName Dot SuperKeyword Dot Name

ThisAccessExpression = ThisKeyword
                     | QName Dot ThisKeyword

ArrayAccessExpression = PrimaryNoTrailingDimensionsNotQName DimensionExpression
                      | QName DimensionExpression

InstanciationExpression = NewKeyword QName Parameters
                        | NewKeyword QName Parameters LBrace MemberList RBrace

ClosureCreationExpression = Type ClosureKeyword Arguments Block

ArrayInstanciationExpressionWithInitializer = NewKeyword Type DimensionExpressions Dimensions ArrayInitializer
                                            | NewKeyword Type DimensionExpressions ArrayInitializer
                                            | NewKeyword Type Dimensions ArrayInitializer

ArrayInstanciationExpressionNoInitializer = NewKeyword Type DimensionExpressions Dimensions
                                          | NewKeyword Type DimensionExpressions

ArrayInitializer = LBrace ExpressionList RBrace | LBrace RBrace
ExpressionList = ExpressionNoTuple | ExpressionList Comma ExpressionNoTuple | ExpressionList Comma

DimensionExpressions = DimensionExpression | DimensionExpressions DimensionExpression
DimensionExpression = LSquare Expression RSquare

Dimensions = LSquare RSquare | Dimensions LSquare RSquare

AssignmentOperator = Equals | PlusEquals | MinusEquals | TimesEquals | DivideEquals | ModEquals
                   | BooleanAndEquals | BooleanOrEquals | BitwiseAndEquals | BitwiseOrEquals | BitwiseXorEquals
                   | LeftShiftEquals | ArithmeticRightShiftEquals | LogicalRightShiftEquals

#########
  Types
#########

// The type lists for Type, PointerType, TypeParameters and TypeArguments have been slightly mutilated
// so that they can cope with a DoubleRAngle token instead of two RAngle tokens
// this results in a lot of rules whose only purpose is to have extra RAngles on the end of them

Type = TypeNotQName | QName
TypeRAngle = TypeNotPointerType RAngle | PointerTypeRAngle
TypeNotQName = TypeNotPointerType | PointerTypeNotQName
TypeNotPointerType = PrimitiveType | ArrayType | TupleType | ClosureType | VoidType

TupleType = LParen TypeList RParen
TypeList = Type | Type Comma TypeList
// right-recursive list, so that the symbol after the list can be
// used to decide between TypeList and AssigneeList

ClosureType = LBrace TypeList Arrow TypeList ThrowsClause RBrace

// QNames are separated out so that ArrayType and ArrayAccess can be disambiguated
// on partial input: class A { int method() { foo[
// where the lookahead token is the final [
ArrayType = TypeNotQName LSquare RSquare | QName LSquare RSquare

PrimitiveType = BooleanType | IntegerType | CharacterType | FloatingType
BooleanType = BooleanKeyword
IntegerType = SignedKeyword ByteKeyword  | UnsignedKeyword ByteKeyword  | ByteKeyword
            | SignedKeyword ShortKeyword | UnsignedKeyword ShortKeyword | ShortKeyword
            | SignedKeyword IntKeyword   | UnsignedKeyword IntKeyword   | IntKeyword
            | SignedKeyword LongKeyword  | UnsignedKeyword LongKeyword  | LongKeyword
CharacterType = CharacterKeyword
FloatingType = FloatKeyword | DoubleKeyword

PointerType = QName | PointerTypeNotQName
PointerTypeRAngle = QName RAngle
                  | PointerTypeNoTrailingParamsNotQName RAngle
                  | PointerTypeTrailingParamsRAngle
PointerTypeNotQName = PointerTypeNoTrailingParamsNotQName
                    | PointerTypeTrailingParams
PointerTypeNoTrailingParamsNotQName = Hash QName
                                    | PointerTypeTrailingParams Dot QName
PointerTypeTrailingParams = QName TypeParameters
                          | Hash QName TypeParameters
                          | PointerTypeTrailingParams Dot QName TypeParameters // the following should be valid: #a.b.C<W, X<Y>>.D.E<Z>.F
PointerTypeTrailingParamsRAngle = QName LAngle TypeParameterListDoubleRAngle
                                | Hash QName LAngle TypeParameterListDoubleRAngle
                                | PointerTypeTrailingParams Dot QName LAngle TypeParameterListDoubleRAngle

TypeParameters = LAngle TypeParameterListRAngle
TypeParameterList = TypeParameter | TypeParameterList Comma TypeParameter
TypeParameterListRAngle = TypeParameterRAngle
                        | TypeParameterList Comma TypeParameterRAngle
TypeParameterListDoubleRAngle = TypeParameterList DoubleRAngle
                              | TypeParameterListRAngle RAngle

TypeParameter = Type | WildcardTypeParameter
TypeParameterRAngle = TypeRAngle
                    | WildcardTypeParameterRAngle
WildcardTypeParameter = QuestionMark
                      | QuestionMark ExtendsKeyword PointerType
                      | QuestionMark SuperKeyword PointerType
                      | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerType
                      | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerType
WildcardTypeParameterRAngle = QuestionMark RAngle
                            | QuestionMark ExtendsKeyword PointerTypeRAngle
                            | QuestionMark SuperKeyword PointerTypeRAngle
                            | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerTypeRAngle
                            | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerTypeRAngle

VoidType = VoidKeyword


TypeArgument = Name
             | Name ExtendsKeyword PointerType
             | Name SuperKeyword PointerType
             | Name ExtendsKeyword PointerType SuperKeyword PointerType
             | Name SuperKeyword PointerType ExtendsKeyword PointerType
TypeArgumentRAngle = Name
                   | Name ExtendsKeyword PointerTypeRAngle
                   | Name SuperKeyword PointerTypeRAngle
                   | Name ExtendsKeyword PointerType SuperKeyword PointerTypeRAngle
                   | Name SuperKeyword PointerType ExtendsKeyword PointerTypeRAngle

TypeArgumentList = TypeArgumentList Comma TypeArgument | TypeArgument
TypeArgumentListRAngle = TypeArgumentRAngle | TypeArgumentList Comma TypeArgumentRAngle
TypeArguments = LAngle TypeArgumentListRAngle


QName = Name | QName Dot Name


################################
  Primitive Tokens (Terminals)
################################

Name

*Literal // anything ending in "Literal" is a terminal which stores a value

*Keyword // anything ending in "Keyword" is a terminal which does not store a value

// any names which sound like a symbol (or DoubleX where X is a symbol) are terminals which do not store values
