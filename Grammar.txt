The grammar for language X
===================================================================================================

###################
  Top Level Stuff
###################

CompilationUnit = epsilon
                | CompilationUnit PackageDeclaration
                | CompilationUnit ImportDeclaration
                | CompilationUnit TypeDefinition

PackageDeclaration = PackageKeyword QName SemiColon

ImportDeclaration  = ImportKeyword QName Semicolon
                   | ImportKeyword QName Dot Star Semicolon
                   | ImportKeyword StaticKeyword QName Semicolon
                   | ImportKeyword StaticKeyword QName Dot Star Semicolon

TypeDefinition = ClassDefinition
               | InterfaceDefinition
               | EnumDefinition

###############
  Class Stuff
###############


AccessSpecifier = PublicKeyword | PrivateKeyword | PackageKeyword | ProtectedKeyword
                | PackageKeyword ProtectedKeyword | ProtectedKeyword PackageKeyword
                | epsilon

Modifiers = Modifier | Modifiers Modifier
Modifier = StaticKeyword | AbstractKeyword | FinalKeyword | ImmutableKeyword | MutableKeyword
         | SynchronizedKeyword | NativeSpecifier | SinceSpecifier | TransientKeyword | VolatileKeyword
NativeSpecifier = NativeKeyword LParen StringLiteral RParen
SinceSpecifier = SinceKeyword LParen VersionNumber RParen
VersionNumber = IntegerLiteral | VersionNumber Dot IntegerLiteral

MemberHeader = AccessSpecifier Modifiers | AccessSpecifier

ClassDefinition     = MemberHeader ClassKeyword Name ClassExtendsClause ImplementsClause LBrace MemberList RBrace
                    | MemberHeader ClassKeyword Name TypeArguments ClassExtendsClause ImplementsClause LBrace MemberList RBrace
InterfaceDefinition = MemberHeader InterfaceKeyword Name TypeArguments InterfaceExtendsClause LBrace MemberList RBrace

EnumDefinition = MemberHeader EnumKeyword Name ClassExtendsClause ImplementsClause LBrace EnumConstants Semicolon MemberList RBrace
               | MemberHeader EnumKeyword Name ClassExtendsClause ImplementsClause LBrace EnumConstants RBrace

EnumConstants = EnumConstantList Comma | EnumConstantList | epsilon
EnumConstantList = EnumConstantList Comma EnumConstant
                 | EnumConstant
EnumConstant = Name | Name Parameters

ClassExtendsClause     = ExtendsKeyword PointerType | epsilon
ImplementsClause       = ImplementsKeyword InterfaceList | epsilon
InterfaceExtendsClause = ExtendsKeyword InterfaceList | epsilon
InterfaceList          = InterfaceList Comma PointerType | PointerType

MemberList = MemberList Member | epsilon
Member = Constructor | Method | Field | StaticInitializer | TypeDefinition

Constructor = MemberHeader Name Arguments ThrowsClause Block

Method = MemberHeader TypeArguments Type Name Arguments ThrowsClause Semicolon
       | MemberHeader TypeArguments Type Name Arguments ThrowsClause Block
       | MemberHeader               Type Name Arguments ThrowsClause Semicolon
       | MemberHeader               Type Name Arguments ThrowsClause Block

ThrowsClause = ThrowsKeyword ThrowsList | epsilon
ThrowsList = PointerType | ThrowsList Comma PointerType

Field = MemberHeader Type DeclarationAssigneeList Equals Expression Semicolon
      | MemberHeader Type DeclarationAssigneeList Semicolon

DeclarationAssigneeList = DeclarationAssignee | DeclarationAssigneeList Comma DeclarationAssignee
DeclarationAssignee = Name | Underscore

Property = MemberHeader PropertyKeyword Type Name Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier AssignKeyword OptionalBlock AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name AccessSpecifier RetrieveKeyword OptionalBlock AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier AssignKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier AssignKeyword OptionalBlock AccessSpecifier RetrieveKeyword OptionalBlock Semicolon
         | MemberHeader PropertyKeyword Type Name Equals Expression AccessSpecifier RetrieveKeyword OptionalBlock AccessSpecifier AssignKeyword OptionalBlock Semicolon

OptionalBlock = Block | epsilon

// MemberHeader is used here instead of StaticKeyword to avoid shift-reduce conflicts
// due to not being able to decide whether to reduce via [ACCESS_SPECIFIER <- ]
// if the next token is "static"
StaticInitializer = MemberHeader Name Block

Arguments = LParen ArgumentList RParen | LParen RParen
ArgumentList = Argument | ArgumentList Comma Argument
Argument = Modifiers Type Name
         | Modifiers Type At Name Equals ExpressionNoTuple
         | Modifiers Type Ellipsis Name
         | Type Name
         | Type At Name Equals ExpressionNoTuple
         | Type Ellipsis Name
         | Arguments

Parameters = LParen ParameterList RParen
           | LParen RParen
ParameterList = Parameter | ParameterList Comma Parameter
Parameter = At Name Equals ExpressionNoTuple
          | ExpressionNoTuple


#########################
  Blocks and Statements
#########################

Block = LBrace RBrace
      | LBrace Statements RBrace
Statements = Statement | Statements Statement

Statement = Block
          | EmptyStatement
          | LocalDeclaration Semicolon
          | Assignment Semicolon
          | IfStatement
          | WhileStatement
          | DoStatement
          | ForStatement
          | ForEachStatement
          | SwitchStatement
          | BreakStatement
          | ContinueStatement
          | FallthroughStatement
          | ReturnStatement
          | SynchronizedStatement
          | ThrowStatement
          | TryStatement
          | Increment Semicolon
          | Decrement Semicolon
          | StatementExpression Semicolon

EmptyStatement = Semicolon

LocalDeclaration = Type DeclarationAssigneeList // check that underscore is not declared after parsing
                 | Type DeclarationAssigneeList Equals Expression
                 | Modifiers Type DeclarationAssigneeList
                 | Modifiers Type DeclarationAssigneeList Equals Expression

Assignment = AssigneeList AssignmentOperator Expression

AssignmentOperator = Equals | PlusEquals | MinusEquals | TimesEquals | DivideEquals | ModEquals
                   | BooleanAndEquals | BooleanOrEquals | BooleanXorEquals | BitwiseAndEquals | BitwiseOrEquals | BitwiseXorEquals
                   | LeftShiftEquals | ArithmeticRightShiftEquals | LogicalRightShiftEquals

// right-recursive list, so that the symbol after the list can be
// used to decide between TypeList and AssigneeList
AssigneeList = Assignee | Assignee Comma AssigneeList
Assignee = FieldAccessExpression | ArrayAccessExpression | Underscore

IfStatement = IfKeyword Expression Block ElseIfClauses ElseClause
ElseIfClauses = epsilon | ElseIfClauses ElseIfClause
ElseIfClause = ElseKeyword IfKeyword Expression Block
ElseClause = epsilon | ElseKeyword Block

WhileStatement = WhileKeyword Expression Block

DoStatement = DoKeyword Block WhileKeyword Expression Semicolon

ForEachStatement = ForKeyword LParen Type Name Colon Expression RParen Block
                 | ForKeyword        Type Name Colon Expression        Block

ForStatement = ForKeyword LParen ForInit Semicolon Expression Semicolon ForUpdate RParen Block
             | ForKeyword        ForInit Semicolon Expression Semicolon ForUpdate        Block
             | ForKeyword LParen ForInit Semicolon            Semicolon ForUpdate RParen Block
             | ForKeyword        ForInit Semicolon            Semicolon ForUpdate        Block

ForInit = LocalDeclaration | StatementExpression | Assignment | epsilon
ForUpdate = StatementExpression | Assignment | Increment | Decrement | epsilon

SwitchStatement = SwitchKeyword Expression LBrace SwitchCases RBrace
                | SwitchKeyword LBrace SwitchCases RBrace
SwitchCases = epsilon | SwitchCases SwitchCase
SwitchCase = DefaultKeyword         Colon
           | DefaultKeyword         Colon Statements
           | CaseKeyword Expression Colon
           | CaseKeyword Expression Colon Statements

BreakStatement = BreakKeyword IntegerLiteral Semicolon
               | BreakKeyword Semicolon
ContinueStatement = ContinueKeyword IntegerLiteral Semicolon
                  | ContinueKeyword Semicolon
FallthroughStatement = FallthroughKeyword IntegerLiteral Semicolon
                     | FallthroughKeyword Semicolon

ReturnStatement = Return Expression Semicolon | Return Semicolon

ThrowStatement = ThrowKeyword Expression Semicolon

SynchronizedStatement = SynchronizedKeyword Expression Block
                      | SynchronizedKeyword Block

TryStatement = TryKeyword Block CatchClauses FinallyClause
CatchClauses = epsilon | CatchClauses CatchClause
CatchClause = CatchKeyword        QName Name        Block
            | CatchKeyword LParen QName Name RParen Block
FinallyClause = FinallyKeyword Block | epsilon

Increment = Assignee Plus  Plus  | Plus  Plus  Assignee
Decrement = Assignee Minus Minus | Minus Minus Assignee

###############
  Expressions
###############

// all of the types of expression that can be used as a statement
StatementExpression = MethodCallExpression | InstanciationExpression

// the basic Expression type, this includes lists of QNames as TupleExpressions
Expression = TupleExpression | QNameList

// NOTE:
// All the following Expressions explicitly exclude lists of just QNames, along
// with single QNames and arbitrarily nested lists of QNames. This is because
// these can easily conflict with a TupleType, a PointerType, or a TypeList.
// The rules work for QNames by having QNameExpression versions of themselves.

// right recursive so that the parser can easily decide between this and
// QNameList
TupleExpression = QName                                  Comma TupleExpression
                | NestedQNameList                        Comma TupleExpression
                | QName           LAngle QName           Comma TupleExpression
                | QName           LAngle NestedQNameList Comma TupleExpression
                | NestedQNameList LAngle QName           Comma TupleExpression
                | NestedQNameList LAngle NestedQNameList Comma TupleExpression
                | InlineIfExpression                     Comma TupleExpression
                | InlineIfExpression                     Comma QNameList
                | InlineIfExpression
                | RelationalExpressionLessThanQName

ExpressionNoTuple = InlineIfExpression | QNameOrLessThanExpression

InlineIfExpression = BooleanOrExpression
                   | BooleanOrExpression       QuestionMark Expression Colon InlineIfExpression
                   | BooleanOrExpression       QuestionMark Expression Colon QNameOrLessThanExpression
                   | QNameOrLessThanExpression QuestionMark Expression Colon InlineIfExpression
                   | QNameOrLessThanExpression QuestionMark Expression Colon QNameOrLessThanExpression

BooleanOrExpression = BooleanXorExpression
                    | BooleanOrExpression       DoublePipe BooleanXorExpression
                    | BooleanOrExpression       DoublePipe QNameOrLessThanExpression
                    | QNameOrLessThanExpression DoublePipe BooleanXorExpression
                    | QNameOrLessThanExpression DoublePipe QNameOrLessThanExpression
BooleanXorExpression = BooleanAndExpression
                     | BooleanXorExpression      DoubleCaret BooleanAndExpression
                     | BooleanXorExpression      DoubleCaret QNameOrLessThanExpression
                     | QNameOrLessThanExpression DoubleCaret BooleanAndExpression
                     | QNameOrLessThanExpression DoubleCaret QNameOrLessThanExpression
BooleanAndExpression = EqualityExpression
                     | BooleanAndExpression      DoubleAmpersand EqualityExpression
                     | BooleanAndExpression      DoubleAmpersand QNameOrLessThanExpression
                     | QNameOrLessThanExpression DoubleAmpersand EqualityExpression
                     | QNameOrLessThanExpression DoubleAmpersand QNameOrLessThanExpression

EqualityExpression = RelationalExpressionNotLessThanQName
                   | EqualityExpression        DoubleEquals           RelationalExpressionNotLessThanQName
                   | EqualityExpression        DoubleEquals           QNameOrLessThanExpression
                   | QNameOrLessThanExpression DoubleEquals           RelationalExpressionNotLessThanQName
                   | QNameOrLessThanExpression DoubleEquals           QNameOrLessThanExpression
                   | EqualityExpression        ExclaimationMarkEquals RelationalExpressionNotLessThanQName
                   | EqualityExpression        ExclaimationMarkEquals QNameOrLessThanExpression
                   | QNameOrLessThanExpression ExclaimationMarkEquals RelationalExpressionNotLessThanQName
                   | QNameOrLessThanExpression ExclaimationMarkEquals QNameOrLessThanExpression

QNameOrLessThanExpression = QNameExpression
                          | RelationalExpressionLessThanQName

// relational expressions which only compare QNames or NestedQNameLists are
// separated out here so that the following is easier to parse:
// class X { void foo() { (a<b,
// since a<b may be the start of a parametrised type or the start of
// a tuple expression which starts in a comparison

RelationalExpressionLessThanQName = QName           LAngle QName
                                  | QName           LAngle NestedQNameList
                                  | NestedQNameList LAngle QName
                                  | NestedQNameList LAngle NestedQNameList

RelationalExpressionNotLessThanQName = BitwiseOrExpression
                                     | BitwiseOrExpression LAngle BitwiseOrExpression
                                     | BitwiseOrExpression LAngle QNameExpression
                                     | QName               LAngle BitwiseOrExpression
                                     | NestedQNameList     LAngle BitwiseOrExpression
                                     | BitwiseOrExpression RAngle BitwiseOrExpression
                                     | BitwiseOrExpression RAngle QNameExpression
                                     | QName               RAngle BitwiseOrExpression
                                     | QName               RAngle QNameExpression
                                     | NestedQNameList     RAngle BitwiseOrExpression
                                     | NestedQNameList     RAngle QNameExpression
                                     | BitwiseOrExpression LAngleEquals BitwiseOrExpression
                                     | BitwiseOrExpression LAngleEquals QNameExpression
                                     | QNameExpression     LAngleEquals BitwiseOrExpression
                                     | QNameExpression     LAngleEquals QNameExpression
                                     | BitwiseOrExpression RAngleEquals BitwiseOrExpression
                                     | BitwiseOrExpression RAngleEquals QNameExpression
                                     | QNameExpression     RAngleEquals BitwiseOrExpression
                                     | QNameExpression     RAngleEquals QNameExpression
                                     | BitwiseOrExpression InstanceOfKeyword Type
                                     | QNameExpression     InstanceOfKeyword Type

BitwiseOrExpression  = BitwiseXorExpression
                     | BitwiseOrExpression Pipe BitwiseXorExpression
                     | BitwiseOrExpression Pipe QNameExpression
                     | QNameExpression     Pipe BitwiseXorExpression
                     | QNameExpression     Pipe QNameExpression
BitwiseXorExpression = BitwiseAndExpression
                     | BitwiseXorExpression Caret BitwiseAndExpression
                     | BitwiseXorExpression Caret QNameExpression
                     | QNameExpression      Caret BitwiseAndExpression
                     | QNameExpression      Caret QNameExpression
BitwiseAndExpression = ShiftExpression
                     | BitwiseAndExpression Ampersand ShiftExpression
                     | BitwiseAndExpression Ampersand QNameExpression
                     | QNameExpression      Ampersand ShiftExpression
                     | QNameExpression      Ampersand QNameExpression

ShiftExpression = AdditiveExpression
                | ShiftExpression DoubleLAngle AdditiveExpression
                | ShiftExpression DoubleLAngle QNameExpression
                | QNameExpression DoubleLAngle AdditiveExpression
                | QNameExpression DoubleLAngle QNameExpression
                | ShiftExpression DoubleRAngle AdditiveExpression
                | ShiftExpression DoubleRAngle QNameExpression
                | QName           DoubleRAngle AdditiveExpression
                | QName           DoubleRAngle QNameExpression
                | NestedQNameList DoubleRAngle AdditiveExpression
                | NestedQNameList DoubleRAngle QNameExpression
                | ShiftExpression TripleRAngle AdditiveExpression
                | ShiftExpression TripleRAngle QNameExpression
                | QName           TripleRAngle AdditiveExpression
                | QName           TripleRAngle QNameExpression
                | NestedQNameList TripleRAngle AdditiveExpression
                | NestedQNameList TripleRAngle QNameExpression

AdditiveExpression = MultiplicativeExpression
                   | AdditiveExpression Plus MultiplicativeExpression
                   | AdditiveExpression Plus QNameExpression
                   | QNameExpression    Plus MultiplicativeExpression
                   | QNameExpression    Plus QNameExpression
                   | AdditiveExpression Minus MultiplicativeExpression
                   | AdditiveExpression Minus QNameExpression
                   | QNameExpression    Minus MultiplicativeExpression
                   | QNameExpression    Minus QNameExpression

MultiplicativeExpression = TupleIndexExpression
                         | MultiplicativeExpression Star TupleIndexExpression
                         | MultiplicativeExpression Star QNameExpression
                         | QNameExpression          Star TupleIndexExpression
                         | QNameExpression          Star QNameExpression
                         | MultiplicativeExpression ForwardSlash TupleIndexExpression
                         | MultiplicativeExpression ForwardSlash QNameExpression
                         | QNameExpression          ForwardSlash TupleIndexExpression
                         | QNameExpression          ForwardSlash QNameExpression
                         | MultiplicativeExpression Percent TupleIndexExpression
                         | MultiplicativeExpression Percent QNameExpression
                         | QNameExpression          Percent TupleIndexExpression
                         | QNameExpression          Percent QNameExpression

TupleIndexExpression = UnaryExpression
                     | TupleIndexExpression ExclaimationMark IntegerLiteral
                     | QNameExpression      ExclaimationMark IntegerLiteral
// TODO: should this be a constant expression instead of an integer literal?

UnaryExpression = Primary
                | CastExpression
                | ExclaimationMark UnaryExpression
                | ExclaimationMark QNameExpression
                | Tilde            UnaryExpression
                | Tilde            QNameExpression
                | Plus             UnaryExpression
                | Plus             QNameExpression
                | Minus            UnaryExpression
                | Minus            QNameExpression
CastExpression = CastKeyword LAngle TypeRAngle UnaryExpression
               | CastKeyword LAngle TypeRAngle QNameExpression

// Primary includes bracketed expressions, but not ones that are nested tuples
// of QNames. Basically, the bracketed expression must have something to
// distinguish itself from a list of qualified names, or an arbitrarily nested
// list of qualified names. This does not allow a QName on its own.
// This is to disambiguate between itself and Type at the start of a statement
Primary = BasicPrimary
        | LParen TupleExpression RParen
        | ArrayInstanciationExpressionNoInitializer

// Trailing Dimensions from ArrayInstanciationNoInitializer are excluded here
// so that ArrayAccessExpression doesn't have a chance to parse the last part
// of: new Object[2][0]
// QNames are excluded here so that ArrayAccessExpression can have its own
// production for QName, which resolves a potential shift reduce conflict
// between an ArrayType and an ArrayAccessExpression
PrimaryNoTrailingDimensionsNotQName = BasicPrimary
                                    | LParen TupleExpression RParen

// Primary, but:
// * no trailing dimensions (square brackets, optionally containing things)
// * not just a QName on its own
// * no bracketed expressions
BasicPrimary = IntegerLiteral   | FloatingLiteral
             | CharacterLiteral | StringLiteral | NilKeyword
             | FieldAccessExpressionNotQName
             | StatementExpression
             | ThisAccessExpression
             | SuperAccessExpression
             | ArrayAccessExpression
             | ClosureCreationExpression
             | ArrayInstanciationExpressionWithInitializer

// an Expression made up entirely of QNames. This can be either a single QName
// or a tupled list of other QNameExpressions.
// this returns either a FieldAccessExpression or a ParenthesisedExpression
// containing a TupleExpression
QNameExpression = QName | NestedQNameList

MethodCallExpression = QNameExpression Parameters
                     | Primary         Parameters

FieldAccessExpression = QName | FieldAccessExpressionNotQName
FieldAccessExpressionNotQName = Primary Dot Name

ThisAccessExpression = ThisKeyword
                     | QName Dot ThisKeyword
SuperAccessExpression = SuperKeyword
                      | QName Dot SuperKeyword

ArrayAccessExpression = PrimaryNoTrailingDimensionsNotQName DimensionExpression
                      | QName DimensionExpression
                      | NestedQNameList DimensionsExpression

InstanciationExpression = NewKeyword PointerType Parameters
                        | NewKeyword PointerType Parameters LBrace MemberList RBrace

ClosureCreationExpression = ClosureKeyword               LParen ArgumentList Arrow TypeList RParen ThrowsClause Block
                          | ClosureKeyword TypeArguments LParen ArgumentList Arrow TypeList RParen ThrowsClause Block
                          | ClosureKeyword               LParen VoidType     Arrow TypeList RParen ThrowsClause Block
                          | ClosureKeyword TypeArguments LParen VoidType     Arrow TypeList RParen ThrowsClause Block

ArrayInstanciationExpressionWithInitializer = NewKeyword TypeNotArrayType DimensionExpressions Dimensions ArrayInitializer
                                            | NewKeyword TypeNotArrayType DimensionExpressions ArrayInitializer
                                            | NewKeyword TypeNotArrayType Dimensions ArrayInitializer

ArrayInstanciationExpressionNoInitializer = NewKeyword TypeNotArrayType DimensionExpressions Dimensions
                                          | NewKeyword TypeNotArrayType DimensionExpressions

ArrayInitializer = LBrace ExpressionList RBrace
                 | LBrace ExpressionList Comma RBrace
                 | LBrace RBrace
ExpressionList = ExpressionNoTuple | ExpressionList Comma ExpressionNoTuple

DimensionExpressions = DimensionExpression | DimensionExpressions DimensionExpression
DimensionExpression = LSquare Expression RSquare

Dimensions = LSquare RSquare | Dimensions LSquare RSquare

#########
  Types
#########

// The type lists for Type, PointerType, TypeParameters and TypeArguments have been slightly mutilated
// so that they can cope with a DoubleRAngle or TripleRAngle token instead of two RAngle tokens
// this results in a lot of rules whose only purpose is to have extra RAngles on the end of them

// Also, some rules have been made to not take QNames and/or NestedQNameLists,
// this is to eliminate shift-reduce and reduce-reduce conflicts between 
// QName lists and other types (e.g. TupleType and NestedQNameList)

Type = TypeNotQName | QName
TypeRAngle = TypeNotPointerTypeNotTupleType RAngle
           | PointerTypeRAngle
           | TupleTypeNotQNameList RAngle
           | NestedQNameList RAngle
TypeDoubleRAngle = TypeNotPointerTypeNotTupleType DoubleRAngle
                 | PointerTypeDoubleRAngle
                 | TupleTypeNotQNameList DoubleRAngle
                 | NestedQNameList DoubleRAngle
TypeTripleRAngle = TypeNotPointerTypeNotTupleType TripleRAngle
                 | PointerTypeTripleRAngle
                 | TupleTypeNotQNameList TripleRAngle
                 | NestedQNameList TripleRAngle
TypeNotQName = TypeNotQNameList | NestedQNameList
TypeNotPointerTypeNotTupleType = PrimitiveType | ArrayType | ClosureType | VoidType
TypeNotArrayType = PrimitiveType | PointerType | TupleType | ClosureType | VoidType
TypeNotQNameList = ArrayType | PrimitiveType | PointerTypeNotQName | TupleTypeNotQNameList | ClosureType | VoidType

TupleType = TupleTypeNotQNameList | NestedQNameList
TupleTypeNotQNameList = LParen TypeListNotQNameList RParen

TypeList = TypeListNotQNameList | QNameList
// a right recursive list that accepts any list of types except a QNameList
// this is so that there are no conflicts between TupleExpression and TypeList
TypeListNotQNameList = QName            Comma TypeListNotQNameList
                     | NestedQNameList  Comma TypeListNotQNameList
                     | TypeNotQNameList Comma TypeList
                     | TypeNotQNameList

ClosureType = LBrace               TypeList Arrow TypeList ThrowsClause RBrace
            | LBrace TypeArguments TypeList Arrow TypeList ThrowsClause RBrace

// QNames are separated out so that ArrayType and ArrayAccess can be disambiguated
// on partial input: class A { int method() { foo[
// where the lookahead token is the final [
ArrayType = TypeNotQNameList LSquare RSquare
          | QName LSquare RSquare
          | NestedQNameList LSquare RSquare

PrimitiveType = BooleanType | IntegerType | CharacterType | FloatingType
BooleanType = BooleanKeyword
IntegerType = SignedKeyword ByteKeyword  | UnsignedKeyword ByteKeyword  | ByteKeyword
            | SignedKeyword ShortKeyword | UnsignedKeyword ShortKeyword | ShortKeyword
            | SignedKeyword IntKeyword   | UnsignedKeyword IntKeyword   | IntKeyword
            | SignedKeyword LongKeyword  | UnsignedKeyword LongKeyword  | LongKeyword
CharacterType = CharacterKeyword
FloatingType = FloatKeyword | DoubleKeyword

PointerType = QName | PointerTypeNotQName
PointerTypeRAngle = QName RAngle
                  | PointerTypeNoTrailingParamsNotQName RAngle
                  | PointerTypeTrailingParamsRAngle
PointerTypeDoubleRAngle = QName DoubleRAngle
                        | PointerTypeNoTrailingParamsNotQName DoubleRAngle
                        | PointerTypeTrailingParamsDoubleRAngle
PointerTypeTripleRAngle = QName TripleRAngle
                        | PointerTypeNoTrailingParamsNotQName TripleRAngle
                        | PointerTypeTrailingParamsTripleRAngle
PointerTypeNotQName = PointerTypeNoTrailingParamsNotQName
                    | PointerTypeTrailingParams
PointerTypeNoTrailingParamsNotQName = Hash QName
                                    | PointerTypeTrailingParams Dot QName
PointerTypeTrailingParams = QName TypeParameters
                          | Hash QName TypeParameters
                          | PointerTypeTrailingParams Dot QName TypeParameters // the following should be valid: #a.b.C<W, X<Y>>.D.E<Z>.F
PointerTypeTrailingParamsRAngle = QName LAngle TypeParameterListDoubleRAngle
                                | Hash QName LAngle TypeParameterListDoubleRAngle
                                | PointerTypeTrailingParams Dot QName LAngle TypeParameterListDoubleRAngle
                                | PointerTypeTrailingParams RAngle
PointerTypeTrailingParamsDoubleRAngle = QName LAngle TypeParameterListTripleRAngle
                                      | Hash QName LAngle TypeParameterListTripleRAngle
                                      | PointerTypeTrailingParams Dot QName LAngle TypeParameterListTripleRAngle
                                      | PointerTypeTrailingParams DoubleRAngle
PointerTypeTrailingParamsTripleRAngle = PointerTypeTrailingParams TripleRAngle

TypeParameters = LAngle TypeParameterListRAngle
TypeParameterList = TypeParameterNotQNameList
                  | QName
                  | NestedQNameList
                  | TypeParameterNotQNameList Comma TypeParameterList
                  | QName                     Comma TypeParameterList
                  | NestedQNameList           Comma TypeParameterList
TypeParameterListRAngle = TypeParameterRAngle
                        | TypeParameterNotQNameList Comma TypeParameterListRAngle
                        | QName                     Comma TypeParameterListRAngle
                        | NestedQNameList           Comma TypeParameterListRAngle
TypeParameterListDoubleRAngle = TypeParameterDoubleRAngle
                              | TypeParameterNotQNameList Comma TypeParameterListDoubleRAngle
                              | QName                     Comma TypeParameterListDoubleRAngle
                              | NestedQNameList           Comma TypeParameterListDoubleRAngle
TypeParameterListTripleRAngle = TypeParameterTripleRAngle
                              | TypeParameterNotQNameList Comma TypeParameterListTripleRAngle
                              | QName                     Comma TypeParameterListTripleRAngle
                              | NestedQNameList           Comma TypeParameterListTripleRAngle

TypeParameterNotQNameList = TypeNotQNameList | WildcardTypeParameter
TypeParameterRAngle = TypeRAngle
                    | WildcardTypeParameterRAngle
TypeParameterDoubleRAngle = TypeDoubleRAngle
                          | WildcardTypeParameterDoubleRAngle
TypeParameterTripleRAngle = TypeTripleRAngle
                          | WildcardTypeParameterTripleRAngle
WildcardTypeParameter = QuestionMark
                      | QuestionMark ExtendsKeyword PointerType
                      | QuestionMark SuperKeyword PointerType
                      | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerType
                      | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerType
WildcardTypeParameterRAngle = QuestionMark RAngle
                            | QuestionMark ExtendsKeyword PointerTypeRAngle
                            | QuestionMark SuperKeyword PointerTypeRAngle
                            | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerTypeRAngle
                            | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerTypeRAngle
WildcardTypeParameterDoubleRAngle = QuestionMark DoubleRAngle
                                  | QuestionMark RAngle RAngle
                                  | QuestionMark ExtendsKeyword PointerTypeDoubleRAngle
                                  | QuestionMark SuperKeyword PointerTypeDoubleRAngle
                                  | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerTypeDoubleRAngle
                                  | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerTypeDoubleRAngle
WildcardTypeParameterTripleRAngle = QuestionMark TripleRAngle
                                  | QuestionMark DoubleRAngle RAngle
                                  | QuestionMark RAngle DoubleRAngle
                                  | QuestionMark RAngle RAngle RAngle
                                  | QuestionMark ExtendsKeyword PointerTypeTripleRAngle
                                  | QuestionMark SuperKeyword PointerTypeTripleRAngle
                                  | QuestionMark ExtendsKeyword PointerType SuperKeyword PointerTypeTripleRAngle
                                  | QuestionMark SuperKeyword PointerType ExtendsKeyword PointerTypeTripleRAngle

VoidType = VoidKeyword


TypeArgument = Name
             | Name ExtendsKeyword PointerType
             | Name SuperKeyword PointerType
             | Name ExtendsKeyword PointerType SuperKeyword PointerType
             | Name SuperKeyword PointerType ExtendsKeyword PointerType
TypeArgumentRAngle = Name
                   | Name ExtendsKeyword PointerTypeRAngle
                   | Name SuperKeyword PointerTypeRAngle
                   | Name ExtendsKeyword PointerType SuperKeyword PointerTypeRAngle
                   | Name SuperKeyword PointerType ExtendsKeyword PointerTypeRAngle

TypeArgumentList = TypeArgumentList Comma TypeArgument | TypeArgument
TypeArgumentListRAngle = TypeArgumentRAngle | TypeArgumentList Comma TypeArgumentRAngle
TypeArguments = LAngle TypeArgumentListRAngle


NestedQNameList = LParen QNameList RParen
QNameList = QName | NestedQNameList
          | QName Comma QNameList
          | NestedQNameList Comma QNameList

QName = Name | QName Dot Name


################################
  Primitive Tokens (Terminals)
################################

Name

*Literal // anything ending in "Literal" is a terminal which stores a value

*Keyword // anything ending in "Keyword" is a terminal which does not store a value

// any names which sound like a symbol (or DoubleX where X is a symbol) are terminals which do not store values
