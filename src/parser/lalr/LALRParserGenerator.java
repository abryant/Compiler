package parser.lalr;

import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import parser.ParseException;
import parser.Production;
import parser.Rule;


/*
 * Created on 21 Jun 2010
 */

/**
 * @author Anthony Bryant
 * @param <T> - the enum type that holds all possible values for the token type
 *
 */
public class LALRParserGenerator<T extends Enum<T>>
{

  private LALRRuleSet<T> rules;

  private LALRState<T> startState = null;

  /**
   * Creates a new LALR parser generator for the specified set of rules.
   * @param rules - the rule set to generate an LALR parser for
   */
  public LALRParserGenerator(LALRRuleSet<T> rules)
  {
    this.rules = rules;
  }

  /**
   * Finds the start state from this parser generator.
   * The start state is generated by calling the generate() method, and if
   * generate() is not called before this method, this method will return null
   * @return the start state generated by this parser generator
   */
  public LALRState<T> getStartState()
  {
    return startState;
  }

  /**
   * Generates the parse table for the set of rules passed into this parser generator.
   * The parse table can be obtained from the getStartState() function.
   * @param generatedStartRuleType - the type in the type enum that will represent the generated start rule and should have its rule added by the generator
   */
  public void generate(T generatedStartRuleType)
  {
    final Rule<T> startRule = rules.getStartRule();

    // create a new start rule to replace the user's start rule
    Rule<T> newStartRule = new GeneratedStartRule<T>(startRule, generatedStartRuleType);
    rules.addStartRule(newStartRule);

    // create the initial item set
    LALRItemSet<T> initialSet = new LALRItemSet<T>();
    LALRItem<T> startItem = new LALRItem<T>(newStartRule, 0, 0);
    startItem.addLookahead(null);
    initialSet.addKernelItem(startItem);
    initialSet.calculateClosureItems(rules);

    // a map from the item set to itself, to ease searching for a particular item set
    // this is needed because equals is overridden and item sets have state that is
    // not considered in equals() or hashCode()
    Map<LALRItemSet<T>, LALRItemSet<T>> itemSets = new HashMap<LALRItemSet<T>, LALRItemSet<T>>();
    itemSets.put(initialSet, initialSet);

    Deque<LALRItemSet<T>> stack = new LinkedList<LALRItemSet<T>>();
    stack.add(initialSet);

    Map<LALRItemSet<T>, Map<T, LALRItemSet<T>>> transitions = new HashMap<LALRItemSet<T>, Map<T,LALRItemSet<T>>>();

    while (!stack.isEmpty())
    {
      LALRItemSet<T> set = stack.pop();

      Map<T, LALRItemSet<T>> setTransitions = findTransitions(set);

      for (Entry<T, LALRItemSet<T>> transition : setTransitions.entrySet())
      {
        LALRItemSet<T> transitionSet = transition.getValue();

        transitionSet.calculateClosureItems(rules);

        LALRItemSet<T> existingSet = itemSets.get(transitionSet);
        if (existingSet == null)
        {
          // a new LALRItemSet has been generated by findTransitions(), so add it to the stack
          itemSets.put(transitionSet, transitionSet);
          stack.add(transitionSet);
          continue;
        }

        if (existingSet.containsLookaheads(transitionSet))
        {
          // an existing LALRItemSet already contains all of this item set's lookaheads and is otherwise equal,
          // so it does not need recalculating, so do not add it to the stack
          continue;
        }
        // an LALRItemSet has been created with the same kernel items as another,
        // but with different lookaheads, so combine the lookaheads and add it to the stack for recalculation
        existingSet.combineLookaheads(transitionSet);
        existingSet.calculateClosureItems(rules);
        transition.setValue(existingSet);
        stack.add(existingSet);
      }
      transitions.put(set, setTransitions);
    }

    startState = generateStates(initialSet, transitions, itemSets.keySet());
  }

  /**
   * Finds all of the transitions from the specified LALRItemSet to other LALRItemSets
   * @param itemSet - the item set to find the transitions from
   * @return the transitions from the specified item set
   */
  private Map<T, LALRItemSet<T>> findTransitions(LALRItemSet<T> itemSet)
  {
    // find the transitions from itemSet to some new LALRItemSet objects
    Map<T, LALRItemSet<T>> transitions = new HashMap<T, LALRItemSet<T>>();
    Set<LALRItem<T>> items = itemSet.getItems();
    for (LALRItem<T> item : items)
    {
      Production<T> production = item.getProduction();
      T[] productionTypes = production.getTypes();
      int offset = item.getOffset();
      // there are no transitions from the end of a production
      if (offset == productionTypes.length)
      {
        continue;
      }

      LALRItem<T> newItem = new LALRItem<T>(item.getRule(), item.getProductionIndex(), offset + 1);
      newItem.addLookaheads(item.getLookaheads());

      LALRItemSet<T> currentTransition = transitions.get(productionTypes[offset]);
      if (currentTransition == null)
      {
        currentTransition = new LALRItemSet<T>();
      }
      currentTransition.addKernelItem(newItem);
      transitions.put(productionTypes[offset], currentTransition);
    }

    return transitions;
  }

  /**
   * Generates the set of states starting at the specified initial state and travelling between states using the specified transitions.
   * The set of states is a graph of associations with the start state as the entry point.
   * @param initialSet - the item set to start with (this is the basis of the start state)
   * @param transitions - the transitions between item sets
   * @param itemSets - the set of all item sets in the graph
   * @return the start state, with the graph of following states fully initialised
   */
  private LALRState<T> generateStates(LALRItemSet<T> initialSet, Map<LALRItemSet<T>, Map<T, LALRItemSet<T>>> transitions, Set<LALRItemSet<T>> itemSets)
  {
    Map<LALRItemSet<T>, LALRState<T>> states = new HashMap<LALRItemSet<T>, LALRState<T>>();

    // create an LALRState for each item set
    for (LALRItemSet<T> set : itemSets)
    {
      states.put(set, new LALRState<T>());
    }

    // build the relationships between the LALRStates
    for (Entry<LALRItemSet<T>, Map<T, LALRItemSet<T>>> entry : transitions.entrySet())
    {
      LALRItemSet<T> itemSet = entry.getKey();
      LALRState<T> state = states.get(itemSet);

      // add the shift and goto actions
      Map<T, LALRItemSet<T>> stateTransitions = entry.getValue();
      for (Entry<T, LALRItemSet<T>> transition : stateTransitions.entrySet())
      {
        T tokenType = transition.getKey();
        LALRItemSet<T> set = transition.getValue();
        if (rules.isTerminal(tokenType))
        {
          state.addShift(tokenType, states.get(set));
        }
        else
        {
          state.addGoto(tokenType, states.get(set));
        }
      }

      // add the reduce actions
      for (LALRItem<T> item : itemSet.getItems())
      {
        if (item.getOffset() < item.getProduction().getTypes().length)
        {
          // this item is not at the end of a rule, so skip it
          continue;
        }
        // add a reduce action for each of the lookaheads of this rule
        for (T lookahead : item.getLookaheads())
        {
          if (lookahead == null && item.getRule().equals(rules.getStartRule()))
          {
            // this is the lookahead for the end of input, and we are at the end of
            // a production in the start rule, so accept on this lookahead
            state.addAccept(lookahead, item.getRule(), item.getProductionIndex());
            continue;
          }
          state.addReduce(lookahead, item.getRule(), item.getProductionIndex());
        }
      }
    }

    return states.get(initialSet);
  }

  /**
   * A Rule which is used as an extra top level rule over the top of the original start rule.
   * @author Anthony Bryant
   */
  static class GeneratedStartRule<T extends Enum<T>> extends Rule<T>
  {
    private static final long serialVersionUID = 1L;

    private Rule<T> startRule;

    @SuppressWarnings("unchecked") // this is unchecked because a generic array has to be created for the varargs
    public GeneratedStartRule(Rule<T> startRule, T type)
    {
      super(type, new Production<T>(startRule.getType()));
      this.startRule = startRule;
    }

    @Override
    public Object match(Production<T> production, Object[] args) throws ParseException
    {
      Object[] productionTypes = production.getTypes();
      if (productionTypes.length == 1 && productionTypes[0] == startRule.getType())
      {
        return args[0];
      }
      throw badTypeList();
    }
  }

}
