package parser;

import java.io.Serializable;

/*
 * Created on 6 Apr 2010
 */

/**
 * A Rule is the basic unit of matching in the parser.
 * The parser condenses lists of input tokens into tokens using rules.
 *
 * @author Anthony Bryant
 * @param <T> - the enum type that holds all possible values for the token type
 *
 */
public abstract class Rule<T extends Enum<T>> implements Serializable
{

  private static final long serialVersionUID = 1L;

  private T type;
  private Production<T>[] productions;

  /**
   * Creates a new rule with the specified type and possible productions.
   * NOTE: the list of productions should be in a predictable order.
   * @param type - the type that this rule reduces to
   * @param productions - the list of productions that can reduce via this rule
   */
  public Rule(T type, Production<T>... productions)
  {
    this.type = type;
    this.productions = productions;
  }

  /**
   * @return the type that this rule will reduce to
   */
  public final T getType()
  {
    return type;
  }

  /**
   * @return the list of productions that this rule can be used to reduce.
   */
  public final Production<T>[] getProductions()
  {
    return productions;
  }

  /**
   * Matches a list of values that have the types associated with one of this rule's productions.
   * The <code>args</code> array will contain exactly the same number of elements as the types of one of the productions,
   * and each element of <code>args</code> will be generated by either the tokenizer or the match method of a rule with
   * the type of the corresponding element in the production.
   * @param production - the production to use to match the arguments
   * @param args - the arguments list, which will have length and types corresponding to one of the productions
   * @return the resulting value object
   * @throws ParseException - if an error occurs while matching
   */
  public abstract Object match(Production<T> production, Object[] args) throws ParseException;

  /**
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object o)
  {
    if (!(o instanceof Rule))
    {
      return false;
    }
    // this is not nice, but is necessary to check whether the rules
    // are equal without knowing their generic type parameters
    @SuppressWarnings("unchecked")
    Rule<T> rule = (Rule<T>) o;
    if (type != rule.type || productions.length != rule.productions.length)
    {
      return false;
    }
    for (int i = 0; i < productions.length; i++)
    {
      if (!productions[i].equals(rule.productions[i]))
      {
        return false;
      }
    }
    return true;
  }

  /**
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode()
  {
    // delegate the hashCode calculation to the type of token this Rule produces.
    // this avoids complex calculations based on the productions,
    // and is fairly efficient as long as the language doesn't define too many
    // rules for the same type
    return type.hashCode();
  }

  /**
   * Returns a string representation of a production.
   * @param <T> - the enum type that holds all possible values for the token type
   * @param type - the type that the production reduces to
   * @param production - the list of types in the production
   * @return a string representation of the production
   */
  public static <T extends Enum<T>> String getProductionString(T type, Production<T> production)
  {
    StringBuffer existingBuffer = new StringBuffer();
    existingBuffer.append("[");
    existingBuffer.append(type);
    existingBuffer.append(" <- ");
    Object[] types = production.getTypes();
    for (int i = 0; i < types.length; i++)
    {
      existingBuffer.append(types[i]);
      if (i != types.length - 1)
      {
        existingBuffer.append(", ");
      }
    }
    existingBuffer.append("]");
    return existingBuffer.toString();
  }

  /**
   * @return a ParseException representing a bad list of types passed to a match() method
   */
  public static ParseException badTypeList()
  {
    return new ParseException("Invalid type list passed to match()");
  }
}
