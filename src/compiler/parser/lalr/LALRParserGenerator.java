package compiler.parser.lalr;

import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import compiler.parser.Rule;

/*
 * Created on 21 Jun 2010
 */

/**
 * @author Anthony Bryant
 *
 */
public class LALRParserGenerator
{

  private LALRRuleSet rules;

  private LALRState startState = null;

  /**
   * Creates a new LALR parser generator for the specified set of rules.
   * @param rules - the rule set to generate an LALR parser for
   */
  public LALRParserGenerator(LALRRuleSet rules)
  {
    this.rules = rules;
  }

  /**
   * Finds the start state from this parser generator.
   * The start state is generated by calling the generate() method, and if
   * generate() is not called before this method, this method will return null
   * @return the start state generated by this parser generator
   */
  public LALRState getStartState()
  {
    return startState;
  }

  /**
   * Generates the parse table for the set of rules passed into this parser generator.
   * The parse table can be obtained from the getStartState() function.
   */
  public void generate()
  {
    Rule startRule = rules.getStartRule();

    // create the initial item set
    LALRItemSet initialSet = new LALRItemSet();
    int productionCount = startRule.getProductions().length;
    for (int i = 0; i < productionCount; i++)
    {
      LALRItem startItem = new LALRItem(startRule, i, 0);
      // add a lookahead item for the end of input, so that an accept rule will be generated for the end of this item
      startItem.addLookahead(null);
      initialSet.addKernelItem(startItem);
    }
    initialSet.calculateClosureItems(rules);

    // a map from the item set to itself, to ease searching for a particular item set
    // this is needed because equals is overridden and item sets have state that is
    // not considered in equals() or hashCode()
    Map<LALRItemSet, LALRItemSet> itemSets = new HashMap<LALRItemSet, LALRItemSet>();
    itemSets.put(initialSet, initialSet);

    Deque<LALRItemSet> stack = new LinkedList<LALRItemSet>();
    stack.add(initialSet);

    Map<LALRItemSet, Map<Object, LALRItemSet>> transitions = new HashMap<LALRItemSet, Map<Object,LALRItemSet>>();

    while (!stack.isEmpty())
    {
      LALRItemSet set = stack.pop();

      Map<Object, LALRItemSet> setTransitions = findTransitions(set);

      for (Entry<Object, LALRItemSet> transition : setTransitions.entrySet())
      {
        LALRItemSet transitionSet = transition.getValue();

        transitionSet.calculateClosureItems(rules);

        LALRItemSet existingSet = itemSets.get(transitionSet);
        if (existingSet == null)
        {
          // a new LALRItemSet has been generated by findTransitions(), so add it to the stack
          itemSets.put(transitionSet, transitionSet);
          stack.add(transitionSet);
          continue;
        }

        if (existingSet.containsLookaheads(transitionSet))
        {
          // an existing LALRItemSet already contains all of this item set's lookaheads and is otherwise equal,
          // so it does not need recalculating, so do not add it to the stack
          continue;
        }
        // an LALRItemSet has been created with the same kernel items as another,
        // but with different lookaheads, so combine the lookaheads and add it to the stack for recalculation
        existingSet.combineLookaheads(transitionSet);
        existingSet.calculateClosureItems(rules);
        transition.setValue(existingSet);
        stack.add(existingSet);
      }
      transitions.put(set, setTransitions);
    }

    startState = generateStates(initialSet, transitions, itemSets.keySet());
  }

  /**
   * Finds all of the transitions from the specified LALRItemSet to other LALRItemSets
   * @param itemSet - the item set to find the transitions from
   * @return the transitions from the specified item set
   */
  private Map<Object, LALRItemSet> findTransitions(LALRItemSet itemSet)
  {
    // find the transitions from itemSet to some new LALRItemSet objects
    Map<Object, LALRItemSet> transitions = new HashMap<Object, LALRItemSet>();
    Set<LALRItem> items = itemSet.getItems();
    for (LALRItem item : items)
    {
      Object[] production = item.getProduction();
      int offset = item.getOffset();
      // there are no transitions from the end of a production
      if (offset == production.length)
      {
        continue;
      }

      LALRItem newItem = new LALRItem(item.getRule(), item.getProductionIndex(), offset + 1);
      newItem.addLookaheads(item.getLookaheads());

      LALRItemSet currentTransition = transitions.get(production[offset]);
      if (currentTransition == null)
      {
        currentTransition = new LALRItemSet();
      }
      currentTransition.addKernelItem(newItem);
      transitions.put(production[offset], currentTransition);
    }

    return transitions;
  }

  /**
   * Generates the set of states starting at the specified initial state and travelling between states using the specified transitions.
   * The set of states is a graph of associations with the start state as the entry point.
   * @param initialSet - the item set to start with (this is the basis of the start state)
   * @param transitions - the transitions between item sets
   * @param itemSets - the set of all item sets in the graph
   * @return the start state, with the graph of following states fully initialised
   */
  private LALRState generateStates(LALRItemSet initialSet, Map<LALRItemSet, Map<Object, LALRItemSet>> transitions, Set<LALRItemSet> itemSets)
  {
    Map<LALRItemSet, LALRState> states = new HashMap<LALRItemSet, LALRState>();

    // create an LALRState for each item set
    for (LALRItemSet set : itemSets)
    {
      states.put(set, new LALRState());
    }

    // build the relationships between the LALRStates
    for (Entry<LALRItemSet, Map<Object, LALRItemSet>> entry : transitions.entrySet())
    {
      LALRItemSet itemSet = entry.getKey();
      LALRState state = states.get(itemSet);

      // add the shift and goto actions
      Map<Object, LALRItemSet> stateTransitions = entry.getValue();
      for (Entry<Object, LALRItemSet> transition : stateTransitions.entrySet())
      {
        Object tokenType = transition.getKey();
        LALRItemSet set = transition.getValue();
        if (rules.isTerminal(tokenType))
        {
          state.addShift(tokenType, states.get(set));
        }
        else
        {
          state.addGoto(tokenType, states.get(set));
        }
      }

      // add the reduce actions
      for (LALRItem item : itemSet.getItems())
      {
        if (item.getOffset() < item.getProduction().length)
        {
          // this item is not at the end of a rule, so skip it
          continue;
        }
        // add a reduce action for each of the lookaheads of this rule
        for (Object lookahead : item.getLookaheads())
        {
          if (lookahead == null && item.getRule().equals(rules.getStartRule()))
          {
            // this is the lookahead for the end of input, and we are at the end of
            // a production in the start rule, so accept on this lookahead
            state.addAccept(lookahead, item.getRule(), item.getProductionIndex());
            continue;
          }
          state.addReduce(lookahead, item.getRule(), item.getProductionIndex());
        }
      }
    }

    return states.get(initialSet);
  }

}
