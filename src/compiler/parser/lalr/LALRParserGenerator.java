package compiler.parser.lalr;

import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

import compiler.parser.Rule;

/*
 * Created on 21 Jun 2010
 */

/**
 * @author Anthony Bryant
 *
 */
public class LALRParserGenerator
{

  private LALRRuleSet rules;

  /**
   * Creates a new LALR parser generator for the specified set of rules.
   * @param rules - the rule set to generate an LALR parser for
   */
  public LALRParserGenerator(LALRRuleSet rules)
  {
    this.rules = rules;
  }

  /**
   * Generates the parse table for the set of rules passed into this parser generator.
   * The parse table can be obtained from the getStartState() function.
   */
  public void generate()
  {
    Rule startRule = rules.getStartRule();

    // create the initial item set
    LALRItemSet initialSet = new LALRItemSet();
    int productionCount = startRule.getProductions().length;
    for (int i = 0; i < productionCount; i++)
    {
      initialSet.addKernelItem(new LALRItem(startRule, i, 0));
    }
    initialSet.calculateClosureItems(rules);

    // a map from the item set to itself, to ease searching for a particular item set
    // this is needed because equals is overridden and item sets have state that is
    // not considered in equals() or hashCode()
    Map<LALRItemSet, LALRItemSet> itemSets = new HashMap<LALRItemSet, LALRItemSet>();
    itemSets.put(initialSet, initialSet);

    Deque<LALRItemSet> stack = new LinkedList<LALRItemSet>();
    stack.add(initialSet);

    Map<LALRItemSet, Map<Object, LALRItemSet>> transitions = new HashMap<LALRItemSet, Map<Object,LALRItemSet>>();

    while (!stack.isEmpty())
    {
      LALRItemSet set = stack.pop();

      Map<Object, LALRItemSet> setTransitions = findTransitions(set);

      for (LALRItemSet transition : setTransitions.values())
      {
        transition.calculateClosureItems(rules);

        LALRItemSet existingSet = itemSets.get(transition);
        if (existingSet == null)
        {
          // a new LALRItemSet has been generated by findTransitions(), so add it to the stack
          itemSets.put(transition, transition);
          stack.add(transition);
          continue;
        }

        if (transition.isIdentical(existingSet))
        {
          // an LALRItemSet has been created exactly equal to another item set,
          // it does not need recalculating, so do not add it to the stack
          continue;
        }
        // an LALRItemSet has been created with the same kernel items as another,
        // but with different lookaheads, so combine the lookaheads and add it to the stack for recalculation
        existingSet.combineLookaheads(transition);
        existingSet.calculateClosureItems(rules);
        stack.add(existingSet);
      }
      transitions.put(set, setTransitions);
    }

    // TODO: generate states
  }

  /**
   * Finds all of the transitions from the specified LALRItemSet to other LALRItemSets
   * @param itemSet - the item set to find the transitions from
   * @return the transitions from the specified item set
   */
  private Map<Object, LALRItemSet> findTransitions(LALRItemSet itemSet)
  {
    // find the transitions from itemSet to some new LALRItemSet objects
    Map<Object, LALRItemSet> transitions = new HashMap<Object, LALRItemSet>();
    Set<LALRItem> items = itemSet.getItems();
    for (LALRItem item : items)
    {
      Object[] production = item.getProduction();
      int offset = item.getOffset();
      // there are no transitions from the end of a production
      if (offset == production.length)
      {
        continue;
      }

      LALRItem newItem = new LALRItem(item.getRule(), item.getProductionIndex(), offset + 1);
      newItem.addLookaheads(item.getLookaheads());

      LALRItemSet currentTransition = transitions.get(production[offset]);
      if (currentTransition == null)
      {
        currentTransition = new LALRItemSet();
      }
      currentTransition.addKernelItem(newItem);
      transitions.put(production[offset], currentTransition);
    }

    return transitions;
  }

  // TODO: document
  // TODO: how should accept actions be generated?
  private LALRState generateStates(LALRItemSet initialItem, Map<LALRItemSet, Map<Object, LALRItemSet>> transitions)
  {
    Map<LALRItemSet, LALRState> states = new HashMap<LALRItemSet, LALRState>();

    // create an LALRState for each item set
    for (LALRItemSet set : transitions.keySet())
    {
      states.put(set, new LALRState());
    }


  }

}
