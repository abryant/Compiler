package compiler.parser;

/*
 * Created on 6 Apr 2010
 */

/**
 * A Rule is the basic unit of matching in the parser.
 * The parser condenses lists of input tokens into tokens using rules.
 *
 * @author Anthony Bryant
 *
 */
public abstract class Rule
{
  private Object type;
  private Object[][] productions;

  /**
   * Creates a new rule with the specified type and possible productions.
   * @param type - the type that this rule reduces to
   * @param productions - the list of productions that can reduce via this rule
   */
  public Rule(Object type, Object[]... productions)
  {
    this.type = type;
    this.productions = productions;
  }

  /**
   * @return the type that this rule will reduce to
   */
  public final Object getType()
  {
    return type;
  }

  /**
   * @return the list of productions that this rule can be used to reduce. This is guaranteed to be the same (unmodified) array that was passed into the constructor.
   */
  public final Object[][] getProductions()
  {
    return productions;
  }

  /**
   * Matches a list of values that have the types associated with one of this rule's productions.
   * The production used is specified in the <code>types</code> array.
   * The <code>args</code> array will contain exactly the same number of elements as one of the productions,
   * and each element of <code>args</code> will be generated by either the tokenizer or the match method of a rule with
   * the type of the corresponding element in the production.
   * @param types - the list of types of the arguments, this will have the same length as the args array
   * @param args - the arguments list, which will have length and types corresponding to one of the productions
   * @return the resulting value object
   * @throws ParseException - if an error occurs while matching
   */
  public abstract Object match(Object[] types, Object[] args) throws ParseException;

  /**
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object o)
  {
    if (!(o instanceof Rule))
    {
      return false;
    }
    Rule rule = (Rule) o;
    if (type != rule.type || productions.length != rule.productions.length)
    {
      return false;
    }
    for (int i = 0; i < productions.length; i++)
    {
      if (productions[i].length != rule.productions[i].length)
      {
        return false;
      }
      for (int j = 0; j < productions[i].length; j++)
      {
        if (productions[i][j] != rule.productions[i][j])
        {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode()
  {
    // delegate the hashCode calculation to the type of token this Rule produces.
    // this avoids complex calculations based on the productions,
    // and is fairly efficient as long as the language doesn't define too many
    // rules for the same type
    return type.hashCode();
  }

  /**
   * Returns a string representation of a production.
   * @param type - the type that the production reduces to
   * @param production - the list of types in the production
   * @return a string representation of the production
   */
  public static String getProductionString(Object type, Object[] production)
  {
    StringBuffer existingBuffer = new StringBuffer();
    existingBuffer.append("[");
    existingBuffer.append(type);
    existingBuffer.append(" <- ");
    for (int i = 0; i < production.length; i++)
    {
      existingBuffer.append(production[i]);
      if (i != production.length - 1)
      {
        existingBuffer.append(", ");
      }
    }
    existingBuffer.append("]");
    return existingBuffer.toString();
  }

  /**
   * @return a ParseException representing a bad list of types passed to a match() method
   */
  public static ParseException badTypeList()
  {
    return new ParseException("Invalid type list passed to match()");
  }
}
