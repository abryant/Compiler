package compiler.parser;

/*
 * Created on 6 Apr 2010
 */

/**
 * A Rule is the basic unit of matching in the parser.
 * The parser condenses lists of input tokens into tokens using rules.
 *
 * @author Anthony Bryant
 *
 */
public abstract class Rule
{
  private Object type;
  private Object[][] requirementTypeLists;

  /**
   * Creates a new rule with the specified type and possible requirement lists.
   * @param type - the type that this rule reduces to
   * @param requirementTypeLists - the lists of requirement types that can reduce via this rule
   */
  public Rule(Object type, Object[]... requirementTypeLists)
  {
    this.type = type;
    this.requirementTypeLists = requirementTypeLists;
  }

  /**
   * @return the type that this rule will reduce to
   */
  public final Object getType()
  {
    return type;
  }

  /**
   * @return the lists of requirement types that this rule can be used to reduce. This is guaranteed to be the same (unmodified) array that was passed into the constructor.
   */
  public final Object[][] getRequirementTypeLists()
  {
    return requirementTypeLists;
  }

  /**
   * Matches a list of values that have the types associated with one of this rule's requirement lists.
   * The type list used is specified in the <code>types</code> array.
   * The <code>args</code> array will contain exactly the same number of elements as one of the requirement type lists,
   * and each element of <code>args</code> will be generated by either the tokenizer or the match method of a rule with
   * the type of the corresponding element in the requirement type list.
   * @param types - the list of types of the arguments, this will have the same length as the args array
   * @param args - the arguments list, which will have length and types corresponding to one of the requirement type lists
   * @return the resulting value object
   */
  public abstract Object match(Object[] types, Object[] args);

  /**
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object o)
  {
    if (!(o instanceof Rule))
    {
      return false;
    }
    Rule rule = (Rule) o;
    if (type != rule.type || requirementTypeLists.length != rule.requirementTypeLists.length)
    {
      return false;
    }
    for (int i = 0; i < requirementTypeLists.length; i++)
    {
      if (requirementTypeLists[i].length != rule.requirementTypeLists[i].length)
      {
        return false;
      }
      for (int j = 0; j < requirementTypeLists[i].length; j++)
      {
        if (requirementTypeLists[i][j] != rule.requirementTypeLists[i][j])
        {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode()
  {
    // delegate the hashCode calculation to the type of token this Rule produces
    // this avoids complex calculations based on the requirement type lists,
    // and is fairly efficient as long as the language doesn't define too many
    // rules for the same type
    return type.hashCode();
  }
}
