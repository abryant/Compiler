package compiler.language.parser;

/*
 * Created on 30 Jun 2010
 */

/**
 * The types used by the language parser.
 * The comment after each type represents the type of value that will be stored in the same token as it.
 * @author Anthony Bryant
 */
public enum ParseType
{
  // =================
  //   NON-TERMINALS
  // =================

  // the rule for this is generated by the parser generator, and it returns
  // the same as the start rule, which is COMPILATION_UNIT
  GENERATED_START_RULE,

  // top level
  COMPILATION_UNIT,         // CompilationUnitAST
  PACKAGE_DECLARATION,      // PackageDeclarationAST
  IMPORT_DECLARATION,       // ImportDeclarationAST
  TYPE_DEFINITION,          // TypeDefinitionAST

  // type definitions
  CLASS_DEFINITION,         // ClassDefinitionAST
  INTERFACE_DEFINITION,     // InterfaceDefinitionAST
  ENUM_DEFINITION,          // EnumDefinitionAST
  CLASS_EXTENDS_CLAUSE,     // PointerTypeAST or null
  INTERFACE_LIST,           // ParseList<PointerTypeAST> (length > 0)
  IMPLEMENTS_CLAUSE,        // ParseList<PointerTypeAST> (length == 0 if not specified)
  INTERFACE_EXTENDS_CLAUSE, // ParseList<PointerTypeAST> (length == 0 if not specified)
  ENUM_CONSTANTS,           // ParseList<EnumConstantAST> (length == 0 if not specified)
  ENUM_CONSTANT_LIST,       // ParseList<EnumConstantAST> (length > 0)
  ENUM_CONSTANT,            // EnumConstantAST

  // members
  ACCESS_SPECIFIER,         // AccessSpecifierAST or null
  MEMBER_HEADER,            // MemberHeaderAST
  MEMBER_LIST,              // ParseList<MemberAST>
  MEMBER,                   // MemberAST
  FIELD,                    // FieldAST
  CONSTRUCTOR,              // ConstructorAST
  METHOD,                   // MethodAST
  PROPERTY,                 // PropertyAST
  STATIC_INITIALIZER,       // StaticInitializerAST

  // statements
  BLOCK,                  // BlockAST
  OPTIONAL_BLOCK,         // BlockAST or null
  STATEMENTS,             // ParseList<StatementAST>
  STATEMENT,              // StatementAST
  EMPTY_STATEMENT,        // EmptyStatementAST
  LOCAL_DECLARATION,      // LocalDeclarationStatementAST
  ASSIGNMENT,             // AssignmentStatementAST
  IF_STATEMENT,           // IfStatementAST
  ELSE_IF_CLAUSES,        // ParseList<ElseIfClauseAST>
  ELSE_IF_CLAUSE,         // ElseIfClauseAST
  ELSE_CLAUSE,            // ParseContainer<BlockAST> (containing null if the empty production is used)
  WHILE_STATEMENT,        // WhileStatementAST
  DO_STATEMENT,           // DoStatementAST
  FOR_EACH_STATEMENT,     // ForEachStatementAST
  FOR_STATEMENT,          // ForStatementAST
  FOR_INIT,               // StatementAST or null
  FOR_UPDATE,             // StatementAST or null
  SWITCH_STATEMENT,       // SwitchStatementAST
  SWITCH_CASES,           // ParseList<SwitchCaseAST>
  SWITCH_CASE,            // SwitchCaseAST
  BREAK_STATEMENT,        // BreakStatementAST
  CONTINUE_STATEMENT,     // ContinueStatementAST
  FALLTHROUGH_STATEMENT,  // FallthroughStatementAST
  RETURN_STATEMENT,       // ReturnStatementAST
  THROW_STATEMENT,        // ThrowStatementAST
  SYNCHRONIZED_STATEMENT, // SynchronizedStatementAST
  TRY_STATEMENT,          // TryStatementAST
  CATCH_CLAUSES,          // ParseList<CatchClauseAST>
  CATCH_CLAUSE,           // CatchClauseAST
  FINALLY_CLAUSE,         // ParseContainer<BlockAST> (containing null if the empty production is used)
  INCREMENT,              // IncrementStatementAST
  DECREMENT,              // DecrementStatementAST


  // expressions
  // the return types that are ExpressionAST (AnotherExpression) mean that if the
  // rule's main production is used (e.g. for additive: a + b) then the type in
  // brackets will be returned but otherwise some other subclass of ExpressionAST
  // will be returned (e.g. ParenthesisedExpressionAST)
  // This is handled in the rules by checking for their created type via
  // 'instanceof', so Bracketed expressions must not just return their argument
  EXPRESSION,                     // ExpressionAST
  STATEMENT_EXPRESSION,           // StatementExpressionAST
  TUPLE_EXPRESSION,               // ExpressionAST (TupleExpressionAST)
  EXPRESSION_NO_TUPLE,            // ExpressionAST
  INLINE_IF_EXPRESSION,           // ExpressionAST (InlineIfExpressionAST)
  BOOLEAN_OR_EXPRESSION,          // ExpressionAST (BooleanOrExpressionAST)
  BOOLEAN_XOR_EXPRESSION,         // ExpressionAST (BooleanXorExpressionAST)
  BOOLEAN_AND_EXPRESSION,         // ExpressionAST (BooleanAndExpressionAST)
  EQUALITY_EXPRESSION,            // ExpressionAST (EqualityExpressionAST)
  QNAME_OR_LESS_THAN_EXPRESSION,  // ExpressionAST (RelationalExpressionAST, FieldAccessExpressionAST or ParenthesisedExpressionAST)
  RELATIONAL_EXPRESSION_LESS_THAN_QNAME,     // ExpressionAST (RelationalExpressionAST or InstanceOfExpressionAST)
  RELATIONAL_EXPRESSION_NOT_LESS_THAN_QNAME, // ExpressionAST (RelationalExpressionAST or InstanceOfExpressionAST)
  BITWISE_OR_EXPRESSION,          // ExpressionAST (BitwiseOrExpressionAST)
  BITWISE_XOR_EXPRESSION,         // ExpressionAST (BitwiseXorExpressionAST)
  BITWISE_AND_EXPRESSION,         // ExpressionAST (BitwiseAndExpressionAST)
  SHIFT_EXPRESSION,               // ExpressionAST (ShiftExpressionAST)
  ADDITIVE_EXPRESSION,            // ExpressionAST (AdditiveExpressionAST)
  MULTIPLICATIVE_EXPRESSION,      // ExpressionAST (MultiplicativeExpressionAST)
  TUPLE_INDEX_EXPRESSION,         // ExpressionAST (TupleIndexExpressionAST)
  UNARY_EXPRESSION,               // ExpressionAST
  CAST_EXPRESSION,                // CastExpressionAST
  PRIMARY,                        // ExpressionAST
  PRIMARY_NO_TRAILING_DIMENSIONS_NOT_QNAME, // ExpressionAST
  BASIC_PRIMARY,                  // ExpressionAST
  BOOLEAN_LITERAL_EXPRESSION,     // BooleanLiteralExpressionAST
  QNAME_EXPRESSION,               // ExpressionAST (either FieldAccessExpressionAST or ParenthesisedExpressionAST)
  METHOD_CALL_EXPRESSION,         // MethodCallExpressionAST
  FIELD_ACCESS_EXPRESSION,        // FieldAccessExpressionAST
  FIELD_ACCESS_EXPRESSION_NOT_QNAME, // FieldAccessExpressionAST
  THIS_ACCESS_EXPRESSION,         // ThisAccessExpressionAST
  SUPER_ACCESS_EXPRESSION,        // SuperAccessExpressionAST
  ARRAY_ACCESS_EXPRESSION,        // ArrayAccessExpressionAST
  INSTANCIATION_EXPRESSION,       // InstanciationExpressionAST
  CLOSURE_CREATION_EXPRESSION,    // ClosureCreationExpressionAST
  ARRAY_INSTANCIATION_EXPRESSION_WITH_INITIALIZER, // ArrayInstanciationExpressionAST
  ARRAY_INSTANCIATION_EXPRESSION_NO_INITIALIZER,   // ArrayInstanciationExpressionAST
  ARRAY_INITIALIZER,              // ParseList<ExpressionAST>
  EXPRESSION_LIST,                // ParseList<ExpressionAST>
  DIMENSION_EXPRESSION,           // ParseContainer<ExpressionAST>
  DIMENSION_EXPRESSIONS,          // ParseList<ExpressionAST>

  // types
  TYPE,                              // TypeAST
  TYPE_RANGLE,                       // ParseContainer<TypeAST>
  TYPE_DOUBLE_RANGLE,                // ParseContainer<ParseContainer<TypeAST>>
  TYPE_TRIPLE_RANGLE,                // ParseContainer<ParseContainer<ParseContainer<TypeAST>>>
  TYPE_NOT_QNAME,                    // TypeAST
  TYPE_NOT_POINTER_TYPE_NOT_TUPLE_TYPE, // TypeAST
  TYPE_NOT_ARRAY_TYPE,               // TypeAST
  TYPE_NOT_QNAME_LIST,               // TypeAST
  TYPE_LIST,                         // ParseList<TypeAST> (length > 0)
  TYPE_LIST_NOT_QNAME_LIST,          // ParseList<TypeAST> (length > 0)
  ARRAY_TYPE,                        // ArrayTypeAST
  TUPLE_TYPE,                        // TupleTypeAST
  TUPLE_TYPE_NOT_QNAME_LIST,         // TupleTypeAST
  CLOSURE_TYPE,                      // ClosureTypeAST
  VOID_TYPE,                         // VoidTypeAST
  PRIMITIVE_TYPE,                    // PrimitiveTypeAST
  BOOLEAN_TYPE,                      // BooleanTypeAST
  INTEGER_TYPE,                      // IntegerTypeAST
  CHARACTER_TYPE,                    // CharacterTypeAST
  FLOATING_TYPE,                     // FloatingTypeAST
  POINTER_TYPE,                      // PointerTypeAST
  POINTER_TYPE_RANGLE,               // ParseContainer<PointerTypeAST>
  POINTER_TYPE_DOUBLE_RANGLE,        // ParseContainer<ParseContainer<PointerTypeAST>>
  POINTER_TYPE_TRIPLE_RANGLE,        // ParseContainer<ParseContainer<ParseContainer<PointerTypeAST>>>
  POINTER_TYPE_NOT_QNAME,            // PointerTypeAST
  POINTER_TYPE_NO_TRAILING_PARAMS_NOT_QNAME,  // PointerTypeAST
  POINTER_TYPE_TRAILING_PARAMS,               // PointerTypeAST
  POINTER_TYPE_TRAILING_PARAMS_RANGLE,        // ParseContainer<PointerTypeAST>
  POINTER_TYPE_TRAILING_PARAMS_DOUBLE_RANGLE, // ParseContainer<ParseContainer<PointerTypeAST>>
  POINTER_TYPE_TRAILING_PARAMS_TRIPLE_RANGLE, // ParseContainer<ParseContainer<ParseContainer<PointerTypeAST>>>
  TYPE_PARAMETERS,                   // ParseList<TypeParameterAST> (length > 0)
  TYPE_PARAMETER_LIST,               // ParseList<TypeParameterAST> (length > 0)
  TYPE_PARAMETER_LIST_RANGLE,        // ParseContainer<ParseList<TypeParameterAST>> (length > 0)
  TYPE_PARAMETER_LIST_DOUBLE_RANGLE, // ParseContainer<ParseContainer<ParseList<TypeParameterAST>>> (length > 0)
  TYPE_PARAMETER_LIST_TRIPLE_RANGLE, // ParseContainer<ParseContainer<ParseContainer<ParseList<TypeParameterAST>>>> (length > 0)
  TYPE_PARAMETER_NOT_QNAME_LIST,     // TypeParameterAST
  TYPE_PARAMETER_RANGLE,             // ParseContainer<TypeParameterAST>
  TYPE_PARAMETER_DOUBLE_RANGLE,      // ParseContainer<ParseContainer<TypeParameterAST>>
  TYPE_PARAMETER_TRIPLE_RANGLE,      // ParseContainer<ParseContainer<ParseContainer<TypeParameterAST>>>
  WILDCARD_TYPE_PARAMETER,           // WildcardTypeParameterAST
  WILDCARD_TYPE_PARAMETER_RANGLE,    // ParseContainer<TypeParameterAST>
  WILDCARD_TYPE_PARAMETER_DOUBLE_RANGLE, // ParseContainer<ParseContainer<TypeParameterAST>>
  WILDCARD_TYPE_PARAMETER_TRIPLE_RANGLE, // ParseContainer<ParseContainer<ParseContainer<TypeParameterAST>>>
  TYPE_BOUND_LIST,                   // ParseList<PointerTypeAST> (length > 0)
  TYPE_BOUND_LIST_RANGLE,            // ParseContainer<ParseList<PointerTypeAST>> (length > 0)
  TYPE_BOUND_LIST_DOUBLE_RANGLE,     // ParseContainer<ParseContainer<ParseList<PointerTypeAST>>> (length > 0)
  TYPE_BOUND_LIST_TRIPLE_RANGLE,     // ParseContainer<ParseContainer<ParseContainer<ParseList<PointerTypeAST>>>> (length > 0)
  TYPE_ARGUMENT,                     // TypeArgumentAST
  TYPE_ARGUMENT_RANGLE,              // ParseContainer<TypeArgumentAST>
  TYPE_ARGUMENT_LIST,                // ParseList<TypeArgumentAST> (length > 0)
  TYPE_ARGUMENT_LIST_RANGLE,         // ParseContainer<ParseList<TypeArgumentAST>> (length > 0)
  TYPE_ARGUMENTS,                    // ParseList<TypeArgumentAST> (length > 0)

  // miscellaneous non-terminals
  MODIFIER,                   // ModifierAST
  MODIFIER_NOT_SYNCHRONIZED,  // ModifierAST
  NATIVE_SPECIFIER,           // NativeSpecifierAST
  MODIFIERS,                  // ParseList<ModifierAST> (length > 0)
  MODIFIERS_NOT_SYNCHRONIZED, // ParseList<ModifierAST> (length > 0)
  ARGUMENT,                   // ArgumentAST
  ARGUMENT_LIST,              // ParseList<ArgumentAST>
  ARGUMENTS,                  // ArgumentListAST
  ASSIGNEE,                   // AssigneeAST
  ASSIGNEE_LIST,              // ParseList<AssigneeAST>
  ASSIGNMENT_OPERATOR,        // ParseContainer<AssignmentOperatorAST>
  DECLARATION_ASSIGNEE,       // DeclarationAssigneeAST
  DECLARATION_ASSIGNEE_LIST,  // ParseList<DeclarationAssigneeAST>
  DIMENSIONS,                 // DimensionsAST
  PARAMETER,                  // ParameterAST
  PARAMETER_LIST,             // ParseList<ParameterAST> (length > 0)
  PARAMETERS,                 // ParseList<ParameterAST>
  QNAME,                      // QNameAST
  QNAME_LIST,                 // ParseList<QNameElementAST>
  NESTED_QNAME_LIST,          // QNameElementAST
  THROWS_LIST,                // ParseList<PointerTypeAST> (length > 0)
  THROWS_CLAUSE,              // ParseList<PointerTypeAST> (length == 0 if none are specified)

  // =============
  //   TERMINALS
  // =============

  // literals
  // all literals must have a special case for extracting ParseInfo from them in LanguageParser
  NAME,              // NameAST
  INTEGER_LITERAL,   // IntegerLiteralAST
  FLOATING_LITERAL,  // FloatingLiteralAST
  CHARACTER_LITERAL, // CharacterLiteralAST
  STRING_LITERAL,    // StringLiteralAST
  SINCE_SPECIFIER,   // SinceSpecifierAST

  // keywords (values for these should all be ParseInfo)
  ABSTRACT_KEYWORD,
  ASSIGN_KEYWORD,
  BOOLEAN_KEYWORD,
  BREAK_KEYWORD,
  BYTE_KEYWORD,
  CASE_KEYWORD,
  CAST_KEYWORD,
  CATCH_KEYWORD,
  CHARACTER_KEYWORD,
  CLASS_KEYWORD,
  CLOSURE_KEYWORD,
  CONTINUE_KEYWORD,
  DEFAULT_KEYWORD,
  DO_KEYWORD,
  DOUBLE_KEYWORD,
  ELSE_KEYWORD,
  ENUM_KEYWORD,
  EXTENDS_KEYWORD,
  FALLTHROUGH_KEYWORD,
  FALSE_KEYWORD,
  FINAL_KEYWORD,
  FINALLY_KEYWORD,
  FLOAT_KEYWORD,
  FOR_KEYWORD,
  IF_KEYWORD,
  IMMUTABLE_KEYWORD,
  IMPLEMENTS_KEYWORD,
  IMPORT_KEYWORD,
  INSTANCEOF_KEYWORD,
  INT_KEYWORD,
  INTERFACE_KEYWORD,
  LONG_KEYWORD,
  MUTABLE_KEYWORD,
  NATIVE_KEYWORD,
  NEW_KEYWORD,
  NIL_KEYWORD,
  PACKAGE_KEYWORD,
  PRIVATE_KEYWORD,
  PROPERTY_KEYWORD,
  PROTECTED_KEYWORD,
  PUBLIC_KEYWORD,
  RETRIEVE_KEYWORD,
  RETURN_KEYWORD,
  SEALED_KEYWORD,
  SHORT_KEYWORD,
  SIGNED_KEYWORD,
  STATIC_KEYWORD,
  SUPER_KEYWORD,
  SWITCH_KEYWORD,
  SYNCHRONIZED_KEYWORD,
  THIS_KEYWORD,
  THROW_KEYWORD,
  THROWS_KEYWORD,
  TRANSIENT_KEYWORD,
  TRUE_KEYWORD,
  TRY_KEYWORD,
  UNSIGNED_KEYWORD,
  VOID_KEYWORD,
  VOLATILE_KEYWORD,
  WHILE_KEYWORD,

  // symbols (values for these should all be ParseInfo)
  AMPERSAND,
  AMPERSAND_EQUALS,
  ARROW, // "->", same as MINUS RANGLE, but without any whitespace between them
  AT,
  CARET,
  CARET_EQUALS,
  COLON,
  COMMA,
  DOT,
  DOUBLE_AMPERSAND,
  DOUBLE_AMPERSAND_EQUALS,
  DOUBLE_CARET,
  DOUBLE_CARET_EQUALS,
  DOUBLE_EQUALS,
  DOUBLE_LANGLE,
  DOUBLE_LANGLE_EQUALS,
  DOUBLE_MINUS,
  DOUBLE_PIPE,
  DOUBLE_PIPE_EQUALS,
  DOUBLE_PLUS,
  DOUBLE_RANGLE,
  DOUBLE_RANGLE_EQUALS,
  ELLIPSIS,
  EQUALS,
  EXCLAIMATION_MARK,
  EXCLAIMATION_MARK_EQUALS,
  FORWARD_SLASH,
  FORWARD_SLASH_EQUALS,
  HASH,
  LANGLE,
  LANGLE_EQUALS,
  LBRACE,
  LPAREN,
  LSQUARE,
  MINUS,
  MINUS_EQUALS,
  PERCENT,
  PERCENT_EQUALS,
  PIPE,
  PIPE_EQUALS,
  PLUS,
  PLUS_EQUALS,
  QUESTION_MARK,
  RANGLE,
  RANGLE_EQUALS,
  RBRACE,
  RPAREN,
  RSQUARE,
  SEMICOLON,
  STAR,
  STAR_EQUALS,
  TILDE,
  TRIPLE_RANGLE,
  TRIPLE_RANGLE_EQUALS,
  UNDERSCORE,
}
